<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>웹캠 맞춤 뷰어</title>
<style>
  :root{--bg:#0b0d10;--fg:#e7ebef;--muted:#a7b0ba;--card:#141a20}
  body{margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui}
  header{padding:14px 18px;border-bottom:1px solid #1f252d;background:#0f141a;
         display:flex;gap:12px;align-items:center;justify-content:space-between}
  header a{color:#cfe3ff;text-decoration:none}
  .btn{cursor:pointer;border:none;background:#1b2530;color:#dfe7ef;border:1px solid #2b3947;border-radius:10px;padding:8px 12px}
  .btn[disabled]{opacity:.5;cursor:not-allowed}

  /* 가운데 정렬 레이아웃 */
  main{padding:18px;display:flex;flex-direction:column;align-items:center;gap:16px}
  .stage{position:relative;line-height:0;width:min(1100px,95vw);margin:0 auto}
  canvas{width:100%;height:auto;display:block;border-radius:12px;background:#10151b;transition:opacity .15s}
  #cam{position:absolute;display:none;object-fit:cover;border:none;border-radius:0;box-shadow:none;pointer-events:none;
       transform:translateZ(0);will-change:left,top,width,height}
  /* 촬영된 결과를 템플릿 자리에 덮어씌우는 전용 IMG */
  #shot{position:absolute;inset:0;display:none;width:100%;height:100%;object-fit:contain;border-radius:12px;z-index:4}

  .panel{background:var(--card);border:1px solid #222b36;border-radius:14px;padding:12px;width:min(1100px,95vw)}
  .hint{font-size:13px;color:var(--muted)}

  /* 설정 패널(토글) */
  .controls{display:none;margin-top:8px}
  .controls.show{display:block}
  .controls label{display:flex;justify-content:space-between;color:var(--muted);margin:8px 0}
  .controls input[type=range]{width:100%}

  /* 이메일 입력 행 */
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .input{flex:1;min-width:240px;padding:8px 10px;border:1px solid #2b3947;border-radius:10px;background:#0f141a;color:#e7ebef}

  /* 카운트다운 오버레이 */
  .countdown{position:absolute;inset:0;display:none;align-items:center;justify-content:center;
             background:rgba(0,0,0,.35);border-radius:12px;z-index:5}
  .countdown.show{display:flex}
  .countnum{font-size:10vw;line-height:1;font-weight:800;text-shadow:0 6px 24px rgba(0,0,0,.6)}
</style>
</head>
<body>
<header>
  <div class="left">
    <a href="/">← 목록</a>
    <strong id="title" style="margin-left:8px">웹캠 맞춤 뷰어</strong>
  </div>
  <div class="right">
    <button id="btnShoot" class="btn">📸 촬영(3초)</button>
    <button id="btnSettings" class="btn" title="설정">⚙️</button>
  </div>
</header>

<main>
  <!-- 템플릿을 페이지 가운데에 -->
  <section class="stage" id="stage">
    <canvas id="cv"></canvas>
    <video id="cam" autoplay muted playsinline></video>

    <!-- 촬영 결과(합성본)를 템플릿 자리에 임시로 표시 -->
    <img id="shot" alt="촬영 결과">

    <!-- 카운트다운 오버레이 -->
    <div id="countdown" class="countdown" aria-hidden="true">
      <div id="countnum" class="countnum">3</div>
    </div>
  </section>

  <!-- 설정(필요할 때만 열기) -->
  <section class="panel">
    <div class="controls" id="controls">
      <label>흰색 허용치 <output id="tolOut">20</output></label>
      <input id="tol" type="range" min="10" max="60" value="20" step="1" oninput="tolOut.textContent=this.value; detectBox();">
      <label>탐색 상단 높이(px) <output id="topOut">420</output></label>
      <input id="top" type="range" min="120" max="1600" value="420" step="10" oninput="topOut.textContent=this.value; detectBox();">
      <label>최소면적(px²) <output id="areaOut">4000</output></label>
      <input id="area" type="range" min="500" max="60000" value="4000" step="500" oninput="areaOut.textContent=this.value; detectBox();">
      <label>Bleed(겹침, px) <output id="bleedOut">4</output></label>
      <input id="bleed" type="range" min="0" max="24" value="4" step="1" oninput="bleedOut.textContent=this.value; positionCam();">
      <p class="hint">Bleed를 올리면 비디오가 박스보다 조금 커져 경계/여백이 전혀 보이지 않습니다.</p>
    </div>
    <p class="hint">필요 시 ⚙️ 버튼으로 설정을 열어 세부 조정하세요.</p>
  </section>

  <!-- 이메일 입력 + 전송 -->
  <section class="panel" style="display:flex;flex-direction:column;gap:10px">
    <div class="row">
      <input id="email" class="input" type="email" placeholder="받는 사람 이메일(예: user@example.com)">
      <button id="btnEmail" class="btn" disabled>✉️ 이메일로 전송</button>
    </div>
    <span id="status" class="hint"></span>
  </section>
</main>

<script>
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const vid = document.getElementById('cam');
const shot = document.getElementById('shot');       // 템플릿 자리 임시 이미지
const titleEl = document.getElementById('title');
const controls = document.getElementById('controls');
const btnSettings = document.getElementById('btnSettings');
const btnShoot = document.getElementById('btnShoot');
const btnEmail = document.getElementById('btnEmail');
const emailInput = document.getElementById('email');
const statusEl = document.getElementById('status');

const countdownEl = document.getElementById('countdown');
const countnumEl = document.getElementById('countnum');

let imgBitmap=null, box=null, lastMergedDataURL=null, showingShot=false;

// 설정 토글
btnSettings.addEventListener('click', ()=> controls.classList.toggle('show'));

// 이메일 유효성 검사 & 버튼 활성화
emailInput.addEventListener('input', enableSendIfReady);
function isValidEmail(v){ return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v); }
function enableSendIfReady(){
  btnEmail.disabled = !(lastMergedDataURL && isValidEmail(emailInput.value));
}

// 템플릿 로드
const params = new URLSearchParams(location.search);
const IMG = params.get('img');
if(!IMG){ alert('이미지 파라미터가 없습니다. /viewer?img=/templates/파일.png'); }
else { titleEl.textContent = `웹캠 맞춤 뷰어 – ${decodeURIComponent(IMG.split('/').pop())}`; loadImage(IMG); startCam(); }

// 반응형 재배치
window.addEventListener('resize', positionCam, {passive:true});
document.addEventListener('scroll', positionCam, {passive:true});

// 이미지 로드
async function loadImage(src){
  const img = await createImageBitmap(await (await fetch(src)).blob());
  imgBitmap = img;
  cv.width = img.width;
  cv.height = img.height;
  drawImage();
  detectBox();
}
function drawImage(){
  ctx.clearRect(0,0,cv.width,cv.height);
  ctx.drawImage(imgBitmap,0,0);
}

// 흰 박스 탐지
function detectBox(){
  if(!imgBitmap) return;
  const tol = +document.getElementById('tol').value;
  const topLimit = +document.getElementById('top').value;
  const minArea = +document.getElementById('area').value;

  const w=cv.width,h=cv.height,searchH=Math.min(topLimit,h);
  const img=ctx.getImageData(0,0,w,searchH);
  const d=img.data;

  const visited=new Uint8Array(w*searchH);
  const idx=(x,y)=>y*w+x;
  const isWhite=(r,g,b)=>r>=255-tol && g>=255-tol && b>=255-tol;
  const getRGB=(x,y)=>{const i=(y*w+x)*4;return[d[i],d[i+1],d[i+2]];}

  const comps=[]; const qx=new Int32Array(w*searchH), qy=new Int32Array(w*searchH);

  for(let y=0;y<searchH;y++){
    for(let x=0;x<w;x++){
      const p=idx(x,y); if(visited[p]) continue;
      const [r,g,b]=getRGB(x,y);
      if(!isWhite(r,g,b)){ visited[p]=1; continue; }

      let head=0,tail=0; qx[tail]=x; qy[tail]=y; tail++; visited[p]=1;
      let minX=x,maxX=x,minY=y,maxY=y,area=0;

      while(head<tail){
        const cx=qx[head], cy=qy[head]; head++; area++;
        if(cx<minX)minX=cx;if(cx>maxX)maxX=cx;
        if(cy<minY)minY=cy;if(cy>maxY)maxY=cy;

        for(const [nx,ny] of [[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]]){
          if(nx<0||ny<0||nx>=w||ny>=searchH) continue;
          const pi=idx(nx,ny); if(visited[pi]) continue;
          const [rr,gg,bb]=getRGB(nx,ny);
          if(!isWhite(rr,gg,bb)){ visited[pi]=1; continue; }
          visited[pi]=1; qx[tail]=nx; qy[tail]=ny; tail++;
        }
      }
      if(area>=minArea) comps.push({minX,minY,maxX,maxY,area});
    }
  }

  if(comps.length===0){ alert('흰 박스를 찾지 못했습니다. 허용치/탐색높이/최소면적 조정'); return; }
  comps.sort((a,b)=>b.area-a.area);
  box = comps[0];
  drawImage();
  positionCam();
}

// 웹캠 시작
async function startCam(){
  if(vid.srcObject) return;
  try{
    const stream = await navigator.mediaDevices.getUserMedia({video:true,audio:false});
    vid.srcObject = stream;
  }catch(e){
    console.error(e); alert('웹캠 권한을 허용해주세요.');
  }
}

// 비디오를 박스에 맞춤
function positionCam(){
  if(!box) return;
  const bleed = +document.getElementById('bleed').value;
  const scaleX = cv.clientWidth / cv.width;
  const scaleY = cv.clientHeight / cv.height;

  const left   = box.minX*scaleX - bleed;
  const top    = box.minY*scaleY - bleed;
  const width  = (box.maxX-box.minX)*scaleX + 2*bleed;
  const height = (box.maxY-box.minY)*scaleY + 2*bleed;

  vid.style.display = showingShot ? 'none' : 'block';
  vid.style.left = left + 'px';
  vid.style.top = top + 'px';
  vid.style.width = width + 'px';
  vid.style.height = height + 'px';
  vid.style.objectFit = 'cover';
}

/* ---------- 카운트다운 유틸 ---------- */
const sleep = ms => new Promise(r=>setTimeout(r, ms));
async function runCountdown(seconds=3){
  countdownEl.classList.add('show');
  for(let t=seconds; t>=1; t--){
    countnumEl.textContent = t;
    await sleep(1000);
  }
  countdownEl.classList.remove('show');
}

/* ---------- 촬영(= 합성 생성) ---------- */
btnShoot.addEventListener('click', async ()=>{
  if(!imgBitmap || !box || !vid.videoWidth){ alert('이미지/웹캠/박스 탐지가 준비되지 않았습니다.'); return; }
  btnShoot.disabled = true; statusEl.textContent = '촬영 준비...';
  await runCountdown(3); // 3초

  // 원본 좌표계에서 합성
  const bleedCss = +document.getElementById('bleed').value;
  const scaleX = cv.clientWidth / cv.width;
  const scaleY = cv.clientHeight / cv.height;
  const bleedX = bleedCss / (scaleX || 1);
  const bleedY = bleedCss / (scaleY || 1);

  const dx = Math.max(0, Math.floor(box.minX - bleedX));
  const dy = Math.max(0, Math.floor(box.minY - bleedY));
  const dw = Math.min(cv.width - dx, Math.floor((box.maxX - box.minX) + 2*bleedX));
  const dh = Math.min(cv.height - dy, Math.floor((box.maxY - box.minY) + 2*bleedY));

  const out = document.createElement('canvas');
  out.width = cv.width;
  out.height = cv.height;
  const octx = out.getContext('2d');
  octx.drawImage(imgBitmap, 0, 0);        // 템플릿
  octx.drawImage(vid, dx, dy, dw, dh);    // 웹캠

  lastMergedDataURL = out.toDataURL('image/png');

  // ▼ 템플릿 영역에 합성본을 잠시 덮어씌움
  shot.src = lastMergedDataURL;
  shot.style.display = 'block';
  cv.style.opacity = '0';       // 레이아웃 유지하면서 숨김(높이 유지)
  showingShot = true;
  positionCam();                // 비디오는 자동으로 숨김
  enableSendIfReady();
  statusEl.textContent = '촬영 완료! 이메일 주소를 입력하고 전송하세요.';
  btnShoot.disabled = false;
});

/* ---------- 이메일로 전송(전송 후 원래 화면으로 복귀) ---------- */
btnEmail.addEventListener('click', async ()=>{
  if(!lastMergedDataURL){ alert('먼저 "촬영(3초)"을 눌러 이미지를 생성하세요.'); return; }
  if(!isValidEmail(emailInput.value)){ alert('이메일 형식이 올바르지 않습니다.'); return; }

  btnEmail.disabled = true;
  statusEl.textContent = '이메일 전송 중...';

  try {
    const filename = `merged_${Date.now()}.png`;
    const res = await fetch('/api/send-email', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({
        to: emailInput.value,
        filename,
        subject: '신문 템플릿 합성 이미지',
        text: '합성된 이미지를 첨부합니다.',
        imageBase64: lastMergedDataURL
      })
    });

    const ct = res.headers.get('content-type') || '';
    if (ct.includes('application/json')) {
      const json = await res.json();
      if(!res.ok) throw new Error(json.error || '전송 실패');

      statusEl.textContent = '전송 완료! 받은편지함을 확인하세요. 화면을 복구합니다.';
      // ▲ 전송 성공 → 원래 템플릿+웹캠 화면으로 복귀
      restoreLiveView();
    } else {
      const text = await res.text();
      throw new Error(`서버가 JSON이 아닌 응답을 돌려줌: ${text.slice(0,120)}…`);
    }
  } catch (e) {
    statusEl.textContent = '전송 오류: ' + e.message;
    console.error(e);
  } finally {
    btnEmail.disabled = false;
  }
});

function restoreLiveView(){
  // 템플릿 자리에 있던 촬영본 감추기
  shot.style.display = 'none';
  showingShot = false;

  // 캔버스/웹캠 복귀
  cv.style.opacity = '1';
  positionCam();

  // 전송 후에는 새 촬영을 유도하도록 상태 초기화
  lastMergedDataURL = null;
  enableSendIfReady();
}
</script>
</body>
</html>
